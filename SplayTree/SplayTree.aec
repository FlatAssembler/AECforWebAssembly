#target WASI // Because we want to make sure all accesses are aligned.

Function noMoreFreeMemory() Which Returns Nothing Is External;
Function segmentationFault() Which Returns Nothing Is External;
Function printString(PointerToCharacter string) Which Returns Nothing Is External;
Function clearScreen() Which Returns Nothing Is External;
Function setDiagramWidth(Integer32 width) Which Returns Nothing Is External;
Function setDiagramHeight(Integer32 height) Which Returns Nothing Is External;
Function drawLine(Integer32 x1, Integer32 y1, Integer32 x2, Integer32 y2)
    Which Returns Nothing Is External;
Function drawRectangle(Integer32 x, Integer32 y,
                       Integer32 width, Integer32 height)
    Which Returns Nothing Is External;
Function drawText(Integer32 x, Integer32 y, PointerToCharacter text)
    Which Returns Nothing Is External;

Function strlen(PointerToCharacter str) Which Returns Integer32 Does
  If str = 0 Then
    Return 0;
  EndIf
  Integer32 length := 0;
  While ValueAt(str + length) Loop
    length += 1;
  EndWhile
  Return length;
EndFunction

Function strcpy(PointerToCharacter dest, PointerToCharacter src) Which Returns Nothing Does
  While ValueAt(src) Loop
    ValueAt(dest) := ValueAt(src);
    dest += 1;
    src += 1;
  EndWhile
  ValueAt(dest) := 0;
EndFunction

Function strcat(PointerToCharacter dest, PointerToCharacter src) Which Returns Nothing Does
  strcpy(dest + strlen(dest), src);
EndFunction

Function reverseString(PointerToCharacter string) Which Returns Nothing Does
  PointerToCharacter pointerToLastCharacter := string + strlen(string) - 1;
  While pointerToLastCharacter - string > 0 Loop
    Character tmp := ValueAt(string);
    ValueAt(string) := ValueAt(pointerToLastCharacter);
    ValueAt(pointerToLastCharacter) := tmp;
    string += 1;
    pointerToLastCharacter -= 1;
  EndWhile
EndFunction

Function convertIntegerToString(PointerToCharacter string, Integer32 number) 
    Which Returns Nothing Does
  Integer32 isNumberNegative := 0;
  If number < 0 Then
    number *= -1;
    isNumberNegative := 1;
  EndIf
  Integer32 i := 0;
  While number >= 10 Loop
    ValueAt(string + i) := '0' + mod(number, 10);
    number /= 10;
    i += 1;
  EndWhile
  ValueAt(string + i) := '0' + number;
  i += 1;
  If isNumberNegative Then 
    ValueAt(string + i) := '-';
    i += 1;
  EndIf
  ValueAt(string + i) := 0;
  reverseString(string);
EndFunction

Function appendIntegerToString(PointerToCharacter string, Integer32 number)
    Which Returns Nothing Does
  convertIntegerToString(string + strlen(string), number);
EndFunction

Structure Node Consists Of
  Integer32 key;
  PointerToNode left, right;
  Integer32 x, y;
EndStructure

InstantiateStructure Node nodes[128];
Integer16 isNodeUsed[128];

Function isNodeWithinBounds(
         PointerToNode node) Which Returns Integer32 Does
  Return AddressOf(nodes[0]) <= node <= AddressOf(nodes[128 - 1]) and
      mod(node - AddressOf(nodes[0]), SizeOf(Node)) = 0;
EndFunction

Function newNode() Which Returns PointerToNode Does
  Integer16 i := 0;
  While i < 128 Loop
    If not(isNodeUsed[i]) Then
      nodes[i].key := 0;
      nodes[i].left :=
         nodes[i].right :=
           PointerToNode(0);
      nodes[i].x := nodes[i].y := 0;
      isNodeUsed[i] := 1;
      Return AddressOf(nodes[i]);
    EndIf
    i += 1;
  EndWhile
  noMoreFreeMemory();
  asm("unreachable");
EndFunction

Function freeNode(
    PointerToNode node) Which Returns Nothing Does
  If not(isNodeWithinBounds(node)) Then
    segmentationFault();
  EndIf
  isNodeUsed[
    (node - AddressOf(nodes[0])) / SizeOf(Node)] := 0;
EndFunction

PointerToNode root; 

Function InsertBST(PointerToNode node, Integer32 key) 
    Which Returns PointerToNode Does
  If not(node) Then
    PointerToNode newNode := newNode();
    newNode->key := key;
    Return newNode;
  EndIf
  If node->key > key Then
    node->left := InsertBST(node->left, key);
  ElseIf node->key < key Then
    node->right := InsertBST(node->right, key);
  EndIf
  Return node;
EndFunction


Function RRotate(PointerToNode y)
    Which Returns PointerToNode Does
  Character stringToBePrinted[32] := {0};
  strcat(AddressOf(stringToBePrinted[0]), "Right-rotate around ");
  appendIntegerToString(
    AddressOf(stringToBePrinted[0]),
    y->key);
  strcat(AddressOf(stringToBePrinted[0]), ".\n");
  printString(AddressOf(stringToBePrinted[0]));

  PointerToNode x := y->left;
  PointerToNode T2 := x->right;
  x->right := y;
  y->left := T2;
 Return x;
EndFunction

Function LRotate(PointerToNode x)
    Which Returns PointerToNode Does
  Character stringToBePrinted[32] := {0};
  strcat(AddressOf(stringToBePrinted[0]), "Left-rotate around ");
  appendIntegerToString(
    AddressOf(stringToBePrinted[0]),
    x->key);
  strcat(AddressOf(stringToBePrinted[0]), ".\n");
  printString(AddressOf(stringToBePrinted[0]));

  PointerToNode y := x->right;
  PointerToNode T2 := y->left;
  y->left := x;
  x->right := T2;
  Return y;
EndFunction

Function Splay(PointerToNode node, Integer32 X)
    Which Returns PointerToNode Does
  If not(node) or node->key = X Then
    Return node;
  ElseIf node->key > X Then
    If not(node->left) Then
      Return node;
    ElseIf node->left->key > X Then
      node->left->left := Splay(node->left->left, X);
      node := RRotate(node);
    ElseIf node->left->key < X Then
      node->left->right := Splay(node->left->right, X);
      If node->left->right Then
        node->left := LRotate(node->left);
      EndIf
    EndIf
    If not(node->left) Then
      Return node;
    Else
      Return RRotate(node);
    EndIf
  Else
    If not(node->right) Then
      Return node;
    ElseIf node->right->key > X Then
      node->right->left := Splay(node->right->left, X);
      If node->right->left Then
        node->right := RRotate(node->right);
      EndIf
    ElseIf node->right->key < X Then
      node->right->right := Splay(node->right->right, X);
      node := LRotate(node);
    EndIf
    If not(node->right) Then
      Return node;
    Else
      Return LRotate(node);
    EndIf
  EndIf
  asm("unreachable");
EndFunction

Function Insert(PointerToNode node, Integer32 X)
    Which Returns PointerToNode Does
  If not(node) Then
    PointerToNode newnode := newNode();
    newnode->key := X;
    Return newnode;
  EndIf
  node := Splay(node, X);
  If node->key = X Then
    Return node;
  EndIf
  PointerToNode newnode := newNode();
  newnode->key := X;

  If node->key > X Then
    newnode->right := node;
    newnode->left := node->left;
    node->left := PointerToNode(0);
  Else
    newnode->left := node;
    newnode->right := node->right;
    node->right := PointerToNode(0);
  EndIf
  Return newnode;
EndFunction

Function Delete(PointerToNode node, Integer32 X)
    Which Returns PointerToNode Does
  PointerToNode temp;
  If not(node) Then
    Return node;
  EndIf
  node := Splay(node, X);
  If not(X = node->key) Then
    Return node;
  EndIf
  If not(node->left) Then
    temp := node;
    node := node->right;
  Else
    temp := node;
    node := Splay(node->left, X);
    node->right := temp->right;
  EndIf
  freeNode(temp);
  Return node;
EndFunction

Function Search(PointerToNode node, Integer32 X)
     Which Returns PointerToNode Does
  Return Splay(node, X);
EndFunction

Integer32 keys[128];
Integer32 numberOfKeys := 0;
Character insert_or_delete[128];

Function getAddressOfKeys() Which Returns PointerToInteger32 Does
  Return AddressOf(keys[0]);
EndFunction

Function getAddressOfInsertOrDelete() Which Returns PointerToCharacter Does
  Return AddressOf(insert_or_delete[0]);
EndFunction

Function setNumberOfKeys(Integer32 n) Which Returns Nothing Does
  numberOfKeys := (n < 0) ? 0 :
                  (n > 128) ? 128 : n;
EndFunction

Function getNumberOfKeys() Which Returns Integer32 Does
  Return numberOfKeys;
EndFunction

Function clearKeys() Which Returns Nothing Does
  numberOfKeys := 0;
EndFunction

Integer32 inorderCounter := 0;

Function assignCoordinatesInorder(PointerToNode node,
                                  Integer32 depth,
                                  Integer32 horizontalSpacing,
                                  Integer32 verticalSpacing)
    Which Returns Nothing Does
  If not(node) Then
    Return;
  EndIf
  assignCoordinatesInorder(node->left,
                           depth + 1,
                           horizontalSpacing,
                           verticalSpacing);
  node->x := inorderCounter * horizontalSpacing;
  node->y := depth * verticalSpacing;
  inorderCounter += 1;
  assignCoordinatesInorder(node->right,
                           depth + 1,
                           horizontalSpacing,
                           verticalSpacing);
EndFunction

Structure Maxima Consists Of
  Integer32 minimumX, maximumX;
EndStructure

Function findMinMaxX(PointerToNode node,
                     PointerToMaxima m) 
    Which Returns Nothing Does
  If not(node) Then
    Return;
  EndIf
  If node->x < m->minimumX Then
    m->minimumX := node->x;
  EndIf
  If node->x > m->maximumX Then
    m->maximumX := node->x;
  EndIf
  findMinMaxX(node->left, m);
  findMinMaxX(node->right, m);
EndFunction

Function drawTree(PointerToNode node, Integer32 offsetX)
    Which Returns Nothing Does
  If not(node) Then 
    Return;
  EndIf
  Integer32 drawX := node->x - offsetX;
  Integer32 drawY := node->y;
  drawRectangle(drawX, drawY, 120, 60);

  Character keyStr[8] := {0};
  convertIntegerToString(AddressOf(keyStr[0]), node->key);
  drawText(drawX + 6, drawY + 30, AddressOf(keyStr[0]));

  If node->left Then
    drawLine(drawX + 60, drawY + 60, node->left->x - offsetX + 60, node->left->y);
    drawTree(node->left, offsetX);
  EndIf
  If node->right Then
    drawLine(drawX + 60, drawY + 60, node->right->x - offsetX + 60, node->right->y);
    drawTree(node->right, offsetX);
  EndIf
EndFunction

Function freeTree(PointerToNode node) Which Returns Nothing Does
  If not(node) Then
    Return;
  EndIf
  If node->left Then 
    freeTree(node->left);
  EndIf
  If node->right Then 
    freeTree(node->right);
  EndIf
  freeNode(node);
EndFunction

Function max(Integer32 x, Integer32 y) Which Returns Integer32 Does
  Return x > y ? x : y;
EndFunction

Function nodeHeight(PointerToNode node)
    Which Returns Integer32 Does
  Return not(node) ? 0 :
         max(nodeHeight(node->left), nodeHeight(node->right)) + 1;
EndFunction

Function render() Which Returns Nothing Does
  clearScreen();
  root := PointerToNode(0);
  Integer32 i := 0;
  While i < numberOfKeys Loop
    If insert_or_delete[i] = 'I' Then
      Character stringToBePrinted[32] := {0};
      strcat(AddressOf(stringToBePrinted[0]), "Inserting ");
      appendIntegerToString(
        AddressOf(stringToBePrinted[0]),
        keys[i]);
      strcat(AddressOf(stringToBePrinted[0]), "...\n");
      printString(AddressOf(stringToBePrinted[0]));

      root := Insert(root, keys[i]);
    ElseIf insert_or_delete[i] = 'D' Then
      Character stringToBePrinted[32] := {0};
      strcat(AddressOf(stringToBePrinted[0]), "Deleting ");
      appendIntegerToString(
        AddressOf(stringToBePrinted[0]),
        keys[i]);
      strcat(AddressOf(stringToBePrinted[0]), "...\n");
      printString(AddressOf(stringToBePrinted[0]));

      root := Delete(root, keys[i]);
    ElseIf insert_or_delete[i] = 'S' Then 
      Character stringToBePrinted[32] := {0};
      strcat(AddressOf(stringToBePrinted[0]), "Searching for ");
      appendIntegerToString(
        AddressOf(stringToBePrinted[0]),
        keys[i]);
      strcat(AddressOf(stringToBePrinted[0]), "...\n");
      printString(AddressOf(stringToBePrinted[0]));

      root := Search(root, keys[i]);
    ElseIf insert_or_delete[i] = 'B' Then
      Character stringToBePrinted[64] := {0};
      strcat(AddressOf(stringToBePrinted[0]), "Inserting ");
      appendIntegerToString(
        AddressOf(stringToBePrinted[0]),
        keys[i]);
      strcat(AddressOf(stringToBePrinted[0]), " as if we were doing a Binary Search Tree...\n");
      printString(AddressOf(stringToBePrinted[0]));

      root := InsertBST(root, keys[i]);
    Else
      printString(R"RawString(The character array "insert_or_delete" can only contain characters 'I', 'B', 'S', and 'D'!
)RawString");
      asm("unreachable");
    EndIf
    i += 1;
  EndWhile

  inorderCounter := 1;
  assignCoordinatesInorder(root, 0, 110, 90);

  InstantiateStructure Maxima globalMax;
  globalMax.minimumX := globalMax.maximumX := 0;
  If root Then
    globalMax.minimumX := root->x;
    globalMax.maximumX := root->x;
    findMinMaxX(root, AddressOf(globalMax));
  EndIf

  Integer32 margin := 20;
  Integer32 diagramWidth := (globalMax.maximumX - globalMax.minimumX) + 120 + margin * 2;
  Integer32 diagramHeight := (nodeHeight(root) + 1) * 90 + margin;

  setDiagramWidth(diagramWidth);
  setDiagramHeight(diagramHeight);

  drawTree(root, globalMax.minimumX - margin);

  freeTree(root);
  printString("Splay Tree rendered.\n");
EndFunction
